# 42. 익명 클래스보다는 람다를 사용하라
과거에는 추상메서드를 하나만 담은 인터페이스가 있었다.
이를 익명클래스로 표현하였는데 이는 구닥다리 방식이다.
이러한 코드들을 람다식으로 사용가능해졌다.


## 구닥다리 코드
```
Collention.sort(words, new Comparator<String()>(){
	public int compare(String s1, String s2){
    	return Integer.compare(s1.length(), s2.length());
    }
});
```
## 람다식으로 변환
```
Collections.sort(words,
	(s1 s2) -> Integer.compare(s1.length(), s2.length()));
```
타입은 컴파일러가 알아서 잘 해주지만 가끔은 명시해줘야할때가 있다.
타입을 명시해야 코드가 더 명활할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자.

**익명 클래스는 (함수형 인터페이스가 아닌)타입의 인스턴스를 만들 때만 사용하라**

# 43. 람다보다는 메서드 참조를 사용하라
람다보다 메서드 참조를 사용하면 더 간결해진다. 
그러나 람다도 장점이 있는데 람다는 길이만 더 길지만 메서드 참조보다는 읽기 쉽고 유지보수가 쉽다.
람다로 구현했을때 너무 길거나 복잡하다면 메서드참조가 좋은 대안이 된다.


# 45. 스트림은 주의해서 사용해라
스트림API는 다량의 데이터 처리 작업(순차적이든 병렬적이든)을 돕고자 자바 8에 추가되었다.
익 가지고 있는 큰 추상 개념은 2가지이다.
1. 스트림은 데이터 원소의 유한 혹은 무한 시퀀스
2. 스트림 파이프라인은 이 원소들로 수행하는 연산 단계를 표현하는 개념이다.


스트림 파이프라인은 지연 평가가 된다. 평가는 종단 연산이 호출될 때 이루어지며, 종단 연산에 쓰이지않는 데이터 원소는 계산에 쓰이지 않는다.  이러한 지연 평가가 무한 스트림을 다룰 수 있게 해주는 열쇠이다. 
종단 연산이 없는 스트림 파이프라인은 아무 일도 하지 않는 명령어인 no-op과 같다.

스트림은 무조건 써야하는 건 아니다.
무분별하게 남용하면 읽기 어렵고 유지보수도 힘들어진다.
스트림을 언제 써야 하는지를 규정하는 확고부동한 규칙은 없지만, 참고할 만한 노하우는 있다.
스트림을 과용하면 프로그램이 읽거나 유지보수하기 어려워진다.
**char 값들을 처리할때는 스트림을 삼가하는 편이 낫다.**

기존 코드에서 스트림을 사용할때는 스트림을 사용해서 리팩터링을 하되, 새 코드가 더 나아보일때
만 하자.

확신이 안서면 기존의 반복을쓰고 확신이 스면 스트림을 사용하자


# 46. 스트림에는 부작용 없는 함수를 사용하라
스트림 패러다임의 핵심은 계산을 일련의 변환으로 재구성하는 부분이다.
이때 각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는 순수 함수여야한다.
> 순수함수란?
오직 입력만이 결과에 영향을 주는 함수를 말한다. 다른 가변 상태를 참조하지 않고, 함수 스스로도 다른 상태를 변경하지 않는다.

이렇게 하려면 스트림 연산에 건네는 함수 객체는 모두 **부작용**이 없어야한다.

**forEach연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산하는 데는 쓰지 말자.**

-------
## Collertors 클래스
이 책은 `java.util.stream.Collectors` 클래스를 괴장히 강조하고 좋다고 말한다.
지금은 그저 축소(reduction)전략을 캡슐화한 블랙박스 객체라고 생각하라고 한다.
여기서 축소란 스트림의 원소들을 객체 하나로 취합한다는 뜻이다.


이 책에서는 빈도표에서 가증 흔한 단어 10개를 뽑는 스트림 파이프라인을 예시로 보여준다.
```
List<String> topTen = freq.keySet().stream()
	.sorted(comparting(freq::get).reversed())
    .limit(10)
    .collect(toList());
```
여기서 어려운 부분은 `comparting(freq::get).reversed()` 이 부분이다.
comapring메서드는 키 추출 함수를 받는 비교자 생성 메서드이다.
freq:get은 입력받은 단어를 빈도표에서 찾아 그 빈도를 반환한다.
그런 다음 가장 흔한 단어가 위로 오도록 비교자를 역순으로 정렬한다.

그 외에도 다른 메서드를 알려준다.
### toMap
#### 인자 2개 toMap
가장 단순한 toMap은 인자가 2가지다
`toMap(keyMapper, valueMapper)`
스트림의 원소를 키에 매핑하는 함수와 값에 매핑하는 함수를 인수로 받는다.
이러한 toMap은 스트림의 각 원소가 고유한 키에 매핑되어 있을때 적합하다.
#### 인자 3개 toMap
인자 3개 toMap은 어떤 키와 그 키에 연관된 원소들 중 하나를 골라 연관 짓는 맵을 만들때 유용하다.
인수가 3개인 toMap은 충돌이 나면 마지막 값을 취하는 수집기를 만들때도 유용하다. 
#### 인자 4개 toMap
네 번째 인수로 맵 팩터리를 받는다.
이 인수로는 EnumMap이나 TreeMap처럼 원하는 특정 맵 구현체를 직접 지정할 수 있다.


### groupinBy
이 메서드는 입력으로 분류 함수를 받고 출력으로는 원소들을 카테고리별로 모아 놓은 맵을 담은 수집기를 반환한다. 분류 함수는 입력받은 원소가 속하는 카테고리를 반환한다. 그리고 이 카테고리가 해당 원소의 맵 키로 쓰인다. 가장 단순한 형태는 분류 함수 하나를 인수로 받아 맵을 반환한다. 반환된 맵에 담긴 각각의 값은 해당 카테고리에 속하는 원소들을 모두 담은 리스트다.
groupingBy가 
#### 세 번째 버전
다운스트림 수집기에 더해 맵 패겉리도 지정할 수 있게 해준다.
이 버전을 사용하면 맵과 그 안에 담긴 컬렉션의 타입을 모두 지정할 수 있다.

### counting
이 메서드가 반환하는 수집기는 다운스트림 수집기 전용이다.
count 메서드를 직접 사용하여 같은 기능을 수행이 가능하니 collect(counting()))형태로 사용할 필요가 없다.

### minBy,maxBy
인수로 받은 비교자를 이용해 스트림에서 가장 작은 값, 가장 큰 값 반환한다.

### joining
이 메서드는 문자열 등의 CharSequence 인스턴스의 스트림에만 적용할 수 있다. 이 중 매개변수가 없는 joining은 단순히 원소들을 연결하는 수집기를 반환한다.
인수가 1개라면 CharSequence 타입의 구분문자(,같은거)를 매개변수로 받는다. 
인수가 3개라면 구분문자에 접두문자 접미문자도 받는다.
